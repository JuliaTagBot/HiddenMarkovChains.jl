import HiddenMarkovChains
HMC = HiddenMarkovChains

using Distributions
using Base.Test

######################################################################
# helper functions
######################################################################

"Random simplex of `n` elements, generated by normalizing draws from
`distribution`."
rand_simplex(n, distribution) = normalize(abs(rand(distribution, n)), 1)

"Random sparse stochastic matrix with size (nrow,ncol).

Matrix has `m` nonzerelements in each row, which are generated by
normalizing the absolute value of draws from `distribution`."
function random_sparse_stochastic_matrix(nrow::Int, m::Int;
                                         distribution = Normal(),
                                         ncol = nrow)
    I = repeat(1:nrow, inner=m)
    J = vcat([sample(1:ncol, m, replace=false) for i in 1:nrow]...)
    V = vcat([rand_simplex(m, distribution) for i in 1:nrow]...)
    sparse(I, J, V, nrow, ncol)
end

function random_stochastic_matrix(nrow; distribution = Normal(), ncol = nrow)
    P = Array(Float64, nrow, ncol)
    for i in 1:nrow
        P[i, :] = rand_simplex(ncol, distribution)
    end
    P
end

@testset "Validating probability vectors and matrices." begin

    @test HMC.isprobvec([0.1, 0.2, 0.7])
    @test !HMC.isprobvec([-0.1, 0.1, 1])
    @test !HMC.isprobvec([0.1, 0.2])
    
    @test HMC.isprobmat(ones(2,3)/3)
    @test !HMC.isprobmat([1.0 2.0;])
    @test !HMC.isprobmat([-1.0 2.0])

end

@testset "Iteration over nonzeros." begin

    @test collect(HMC.column_nz(reshape(1:9, 3, 3), 2))==[(1,4), (2,5), (3,6)]
    @test collect(HMC.column_nz(sparse([1,1,3,2],
                                       [1,2,2,3],
                                       [2,3,5,7]), 2))==[(1,3), (3,5)]
end

######################################################################
# TEST: steady state calculations
######################################################################

@testset "Steady state calculations." begin

    @test_throws DimensionMismatch HMC.steady_state(ones(2,3)/3)
    
    "Steady state calculation error."
    function ss_error(P)
        p = HMC.steady_state(P)
        norm(p'*P-p', 1)
    end
    
    for i in 1:1000
    @test ss_error(random_sparse_stochastic_matrix(9, 4)) < 1e-10
    end
    
    for i in 1:1000
        @test ss_error(random_stochastic_matrix(9)) < 1e-10
    end

end

@testset "Path simulations." begin

    "Simulate a path of length `T` from HMC (P,Q), with initial
    distribution `p`."
    function simulate_path(p::AbstractVector, P::AbstractMatrix,
                           Q::AbstractMatrix, T::Int)
    _rand(v) = rand(Categorical(v))
        _rand(M, i) = _rand(collect(M[i, :]))
        i = _rand(p)
        path = Array(Int64, T)
        for t in 1:T
            path[t] = _rand(Q, i)
            if t != T
                i = _rand(P, i)
        end
        end
        path
    end

    "Simulated probabilities for paths, using `n` draws. See
    `simulate_path` for the other parameters."
    function simulate_path_probabilities(p::AbstractVector, P::AbstractMatrix,
                                         Q::AbstractMatrix, T::Int, n::Int)
    counts = Dict{Array{Int64,1},Int64}()
        for i in 1:n
            path = simulate_path(p, P, Q, T)
            counts[path] = get(counts, path, 0) + 1
        end
        Dict(path => count/n for (path, count) in counts)
    end
    
"Average and largest absolute difference in probabilities. Iterates over
    paths in `pp`."
    function path_probabilities_difference(pp, pp_sim)
        sumdiff = 0.0
        maxdiff = 0.0
        for (path, prob) in pp
            diff = abs(pp_sim[path] - prob)
            sumdiff += diff
            maxdiff = max(maxdiff, diff)
        end
        (sumdiff/length(pp), maxdiff)
    end
    
    "Paths in simulation which are not covered by exact calculations. A
    nonempty set is a cause for concern."
    uncovered_paths(pp, pp_sim) = setdiff(keys(pp_sim), keys(pp))
    
    let P = random_sparse_stochastic_matrix(5, 3),
        Q = random_stochastic_matrix(5; ncol=3),
        p = HMC.steady_state(P),
        T = 3, 
        pp = HMC.path_probabilities(P, Q, p, T),
        pp_sim = simulate_path_probabilities(p, P, Q, T, 10000),
        diffs = path_probabilities_difference(pp, pp_sim)
        @test diffs < (0.01,0.01)
        @test length(uncovered_paths(pp, pp_sim)) == 0
    end

end
